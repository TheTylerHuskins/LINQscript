import { IQueryable, IEqualityComparer, IGrouping, IQueryCallback, IQueryPredicate, IQuerySelector } from "./IQueryable";
export declare class Queryable<TSource> implements IQueryable<TSource> {
    private IITer;
    static FromIterable<T>(source: Iterable<T>): IQueryable<T>;
    static FromIterator<T>(source: IndexedIterator<T>): IQueryable<T>;
    constructor(source: Iterable<TSource> | IndexedIteratorChain<TSource>);
    ForEach(callback: IQueryCallback<TSource>): void;
    SelectManyRecursive(selector: IQuerySelector<TSource, Iterable<TSource>>): IQueryable<TSource>;
    Where(predicate: IQueryPredicate<TSource>): IQueryable<TSource>;
    Select<TResult>(selector: IQuerySelector<TSource, TResult>): IQueryable<TResult>;
    SelectMany<TResult>(selector: IQuerySelector<TSource, Iterable<TResult>>): IQueryable<TResult>;
    SelectMany<TInner, TResult>(selector: IQuerySelector<TSource, Iterable<TInner>>, resultSelector: IQuerySelector<TInner, TResult>): IQueryable<TResult>;
    Take(count: number): IQueryable<TSource>;
    Skip(count: number): IQueryable<TSource>;
    TakeWhile(predicate: IQueryPredicate<TSource>): IQueryable<TSource>;
    SkipWhile(predicate: IQueryPredicate<TSource>): IQueryable<TSource>;
    Join<TInner, TKey, TResult>(inner: Iterable<TInner>, outerKeySelector: IQuerySelector<TSource, TKey>, innerKeySelector: IQuerySelector<TInner, TKey>, resultSelector: (outer: TSource, inner: TInner) => TResult, comparer: IEqualityComparer<TKey>): IQueryable<TResult>;
    Concat(other: Iterable<TSource>): IQueryable<TSource>;
    Reverse(): IQueryable<TSource>;
    GroupBy<TKey, TElement>(keySelector: IQuerySelector<TSource, TKey>, elementSelector: IQuerySelector<TSource, TElement>, comparer: IEqualityComparer<TKey>): IQueryable<IGrouping<TKey, TElement>>;
    Distinct(comparer: IEqualityComparer<TSource>): IQueryable<TSource>;
    Union(other: Iterable<TSource>, comparer: IEqualityComparer<TSource>): IQueryable<TSource>;
    Intersect(other: Iterable<TSource>, comparer: IEqualityComparer<TSource>): IQueryable<TSource>;
    Except(other: Iterable<TSource>, comparer: IEqualityComparer<TSource>): IQueryable<TSource>;
    ToArray(): Array<TSource>;
    AsIterable(): Iterable<TSource>;
    ToMap<TKey, TElement>(keySelector: IQuerySelector<TSource, TKey>, elementSelector: IQuerySelector<TSource, TElement>, comparer: IEqualityComparer<TKey>): Map<TKey, TElement>;
    OfType(type: "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function"): IQueryable<TSource>;
    Cast<TResult>(): IQueryable<TResult>;
    SequenceEqual(other: Iterable<TSource>, comparer?: IEqualityComparer<TSource>): boolean;
    First(predicate?: IQueryPredicate<TSource>): TSource;
    FirstOrDefault(def?: TSource, predicate?: IQueryPredicate<TSource>): TSource | undefined;
    Any(predicate?: IQueryPredicate<TSource>): boolean;
    private FromNexter;
}
